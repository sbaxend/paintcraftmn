---
/* src/components/exterior/ExteriorServices.astro */

type Service = {
  id: string;
  title: string;
  img: string;   // /public path
  href?: string;
};

export interface Props {
  heading?: string;
  sub?: string;
  services?: Service[];
}

const {
  heading = "Our Exterior Services",
  sub = "Durable finishes and curb-appeal upgrades built for Minnesota weather.",
  services = [
    { id: "siding",  title: "Siding",             img: "/services/exterior/siding.jpg" },
    { id: "trim",    title: "Trim",               img: "/services/exterior/trim.jpg" },
    { id: "deck",    title: "Deck & Fence",       img: "/services/exterior/deck.jpg" },
    { id: "garage",  title: "Garage Doors",       img: "/services/exterior/garage.jpg" },
    { id: "stucco",  title: "Stucco/Masonry",     img: "/services/exterior/stucco.jpg" },
    { id: "doors",   title: "Doors & Windows",    img: "/services/exterior/doors.jpg" },
  ],
} = Astro.props as Props;

// Ensure each service has a working link like /exterior/trim
const items: Service[] = services.map(s => ({ ...s, href: `/exterior/${s.id}` }));

const sectionId = "exterior-services";
---

<section id={sectionId} class="relative bg-white">
  <div class="mx-auto max-w-7xl px-6 pt-10 text-center">
    <h2 class="font-serif text-3xl md:text-5xl font-semibold text-neutral-900">{heading}</h2>
    <p class="mt-3 text-neutral-600">{sub}</p>
  </div>

  <!-- Full-bleed carousel wrapper -->
  <div id="svc-wrap" class="relative -mx-6 md:-mx-10 mt-8" style="--svc-gutter:3.2vw;">
    <!-- soft edge fades -->
    <div class="pointer-events-none absolute left-0 top-0 h-full w-16 md:w-24 bg-gradient-to-r from-white to-transparent"></div>
    <div class="pointer-events-none absolute right-0 top-0 h-full w-16 md:w-24 bg-gradient-to-l from-white to-transparent"></div>

    <!-- hover zones (desktop only) -->
    <div id="svc-hover-left"  class="hidden md:block absolute left-0 top-0 z-20 h-full w-[12vw]"></div>
    <div id="svc-hover-right" class="hidden md:block absolute right-0 top-0 z-20 h-full w-[12vw]"></div>

    <!-- track -->
    <div
      id="svc-track"
      class="relative flex gap-6 overflow-x-auto overflow-y-visible snap-x snap-mandatory scroll-smooth
             pb-2 pt-1 px-[var(--svc-gutter)]
             [-ms-overflow-style:none] [scrollbar-width:none]
             [mask-image:linear-gradient(90deg,transparent,black_6%,black_94%,transparent)]"
      style="scroll-padding-inline: var(--svc-gutter);"
      aria-label="Exterior services"
    >
      <style>#svc-track::-webkit-scrollbar{display:none}</style>

      <!-- edge spacers prevent first/last card clipping + keep shadows intact -->
      <div class="shrink-0 w-[var(--svc-gutter)]" aria-hidden="true"></div>

      {items.map((s) => (
        <a
          href={s.href}
          class="svc-card snap-center shrink-0 relative overflow-hidden rounded-[24px] md:rounded-[26px]
                 w-[88vw] xs:w-[78vw] sm:w-[62vw] md:w-[46vw] lg:w-[36vw] xl:w-[30vw]
                 aspect-[16/10] ring-1 ring-black/10 bg-transparent
                 shadow-[0_14px_50px_rgba(0,0,0,.12)] focus:outline-none focus:ring-4 focus:ring-black/10"
        >
          <div class="card-lift absolute inset-0 will-change-transform">
            <img src={s.img} alt={s.title} class="absolute inset-0 h-full w-full object-cover" loading="lazy" decoding="async" />
            <div class="pointer-events-none absolute inset-x-0 bottom-0 h-1/2
                        bg-[linear-gradient(180deg,rgba(0,0,0,0)_0%,rgba(0,0,0,.22)_45%,rgba(0,0,0,.55)_100%)]"></div>
          </div>
          <div class="absolute inset-0 grid place-items-end p-6">
            <h3 class="text-white text-[clamp(20px,3.0vw,34px)] font-extrabold tracking-tight drop-shadow">
              {s.title}
            </h3>
          </div>
        </a>
      ))}

      <div class="shrink-0 w-[var(--svc-gutter)]" aria-hidden="true"></div>
    </div>
  </div>
</section>

<!-- Interactions -->
<script lang="ts" is:inline>
(() => {
  const track = document.getElementById('svc-track') as HTMLDivElement | null;
  if (!track) return;

  /** Tunables */
  const BTN_PAGE_FACTOR = 0.85;   // used by arrow keys
  const EDGE_ZONE       = 120;    // px for hover glide
  const EDGE_SPEED_MAX  = 18;     // px / frame for edge glide
  const DRAG_FRICTION   = 0.93;   // momentum decay
  const WHEEL_MULT      = 1.0;    // vertical wheel -> horizontal

  /* 1) Wheel â†’ horizontal */
  track.addEventListener('wheel', (e: WheelEvent) => {
    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
      track.scrollLeft += e.deltaY * WHEEL_MULT;
      e.preventDefault();
    }
  }, { passive: false });

  /* 2) Click/drag with momentum */
  let isDown = false, startX = 0, startLeft = 0, lastX = 0, vx = 0, raf = 0;
  const stopRAF = () => { if (raf) cancelAnimationFrame(raf); raf = 0; };
  const momentum = () => {
    if (Math.abs(vx) < 0.25) return;
    track.scrollLeft -= vx;
    vx *= DRAG_FRICTION;
    raf = requestAnimationFrame(momentum);
  };
  track.addEventListener('pointerdown', (e: PointerEvent) => {
    isDown = true;
    startX = lastX = e.clientX;
    startLeft = track.scrollLeft;
    vx = 0;
    stopRAF();
    track.setPointerCapture(e.pointerId);
  });
  track.addEventListener('pointermove', (e: PointerEvent) => {
    if (!isDown) return;
    const dx = e.clientX - startX;
    track.scrollLeft = startLeft - dx;
    vx = e.clientX - lastX;
    lastX = e.clientX;
  });
  const endDrag = (e: PointerEvent) => {
    if (!isDown) return;
    isDown = false;
    try { track.releasePointerCapture(e.pointerId); } catch {}
    momentum();
  };
  track.addEventListener('pointerup', endDrag);
  track.addEventListener('pointerleave', () => { isDown = false; });

  /* 3) Keyboard arrows (focusable track) */
  const page = (dir: number) =>
    track.scrollBy({ left: dir * track.clientWidth * BTN_PAGE_FACTOR, behavior: 'smooth' });
  track.setAttribute('tabindex', '0');
  track.addEventListener('keydown', (e: KeyboardEvent) => {
    if (e.key === 'ArrowRight') { page(+1); e.preventDefault(); }
    if (e.key === 'ArrowLeft')  { page(-1); e.preventDefault(); }
  });

  /* 4) Edge hover glide (desktop pointers) */
  const leftZone  = document.getElementById('svc-hover-left')  as HTMLDivElement | null;
  const rightZone = document.getElementById('svc-hover-right') as HTMLDivElement | null;

  if (matchMedia('(pointer:fine)').matches && leftZone && rightZone) {
    let hoverRAF = 0;
    const startGlide = (dir: -1 | 1, zone: HTMLDivElement) => {
      const onMove = (e: MouseEvent) => {
        const rect = zone.getBoundingClientRect();
        const dist = dir < 0 ? e.clientX - rect.left : rect.right - e.clientX;
        const mx = Math.max(0, Math.min(EDGE_ZONE, dist));
        const t = 1 - (mx / EDGE_ZONE);
        const speed = dir * (EDGE_SPEED_MAX * t);
        track.scrollLeft += speed;
        hoverRAF = requestAnimationFrame(() => onMove(e));
      };
      const enter = (e: MouseEvent) => {
        cancelAnimationFrame(hoverRAF);
        hoverRAF = requestAnimationFrame(() => onMove(e));
        zone.addEventListener('mousemove', onMove);
      };
      const leave = () => {
        cancelAnimationFrame(hoverRAF);
        zone.removeEventListener('mousemove', onMove);
      };
      zone.addEventListener('mouseenter', enter as any);
      zone.addEventListener('mouseleave', leave);
    };
    startGlide(-1, leftZone);
    startGlide(+1, rightZone);
  }

  /* 5) Snap the nearest card to center after wheel settles */
  let snapTO: number | undefined;
  const cards = Array.from(track.querySelectorAll('.svc-card')) as HTMLElement[];
  const snapCenter = () => {
    if (!cards.length) return;
    const mid = track.scrollLeft + track.clientWidth / 2;
    let best: { el: HTMLElement; d: number } | null = null;
    for (const el of cards) {
      const cx = el.offsetLeft + el.offsetWidth / 2;
      const d = Math.abs(cx - mid);
      if (!best || d < best.d) best = { el, d };
    }
    best?.el.scrollIntoView({ inline: 'center', block: 'nearest', behavior: 'smooth' });
  };
  track.addEventListener('wheel', () => {
    clearTimeout(snapTO);
    snapTO = window.setTimeout(snapCenter, 140);
  }, { passive: true });

  /* 6) Parallax hover on each card */
  cards.forEach((card) => {
    const lift = card.querySelector('.card-lift') as HTMLElement | null;
    if (!lift) return;
    card.addEventListener('mousemove', (e: MouseEvent) => {
      const r = card.getBoundingClientRect();
      const rx = (e.clientX - r.left) / r.width - 0.5;
      const ry = (e.clientY - r.top)  / r.height - 0.5;
      lift.style.transform = `translate3d(${rx * 10}px, ${ry * 10}px, 0) scale(1.02)`;
    });
    card.addEventListener('mouseleave', () => {
      lift.style.transform = 'translate3d(0,0,0) scale(1)';
    });
  });
})();
</script>
