---
/* ExteriorServices.astro */
type Service = {
  id: string;
  title: string;
  img: string;   // /public path
  href?: string;
};

export interface Props {
  heading?: string;
  sub?: string;
  services?: Service[];
}

const {
  heading = "Our Exterior Services",
  sub = "Durable finishes and curb-appeal upgrades built for Minnesota weather.",
  services = [
    { id: "siding",  title: "Siding",             img: "/services/exterior/siding.jpg" },
    { id: "trim",    title: "Trim",               img: "/services/exterior/trim.jpg" },
    { id: "deck",    title: "Deck & Fence",       img: "/services/exterior/deck.jpg" },
    { id: "garage",  title: "Garage Doors",       img: "/services/exterior/garage.jpg" },
    { id: "stucco",  title: "Stucco/Masonry",     img: "/services/exterior/stucco.jpg" },
    { id: "doors",   title: "Doors & Windows",    img: "/services/exterior/doors.jpg" },
  ],
} = Astro.props as Props;

const sectionId = "exterior-services";
---

<section id={sectionId} class="relative bg-white">
  <div class="mx-auto max-w-7xl px-6 pt-10 text-center">
    <h2 class="font-serif text-3xl md:text-5xl font-semibold text-neutral-900">{heading}</h2>
    <p class="mt-3 text-neutral-600">{sub}</p>
  </div>

  <!-- Full-bleed carousel wrapper (no visible gray panel) -->
  <div id="svc-wrap" class="relative -mx-6 md:-mx-10 mt-8" style="--svc-gutter:3.2vw;">
    <!-- soft edge fades -->
    <div class="pointer-events-none absolute left-0 top-0 h-full w-16 md:w-24 bg-gradient-to-r from-white to-transparent"></div>
    <div class="pointer-events-none absolute right-0 top-0 h-full w-16 md:w-24 bg-gradient-to-l from-white to-transparent"></div>

    <!-- hover zones (desktop only) -->
    <div id="svc-hover-left"  class="hidden md:block absolute left-0 top-0 z-20 h-full w-[12vw]"></div>
    <div id="svc-hover-right" class="hidden md:block absolute right-0 top-0 z-20 h-full w-[12vw]"></div>

    <!-- track -->
    <div
      id="svc-track"
      class="relative flex gap-6 overflow-x-auto snap-x snap-mandatory scroll-smooth
             pb-2 pt-1 px-[var(--svc-gutter)]
             [-ms-overflow-style:none] [scrollbar-width:none]
             [mask-image:linear-gradient(90deg,transparent,black_6%,black_94%,transparent)]"
      aria-label="Exterior services"
    >
      <style>#svc-track::-webkit-scrollbar{display:none}</style>

      {services.map((s) => (
        <a
          href={s.href || "#"}
          class="svc-card snap-center shrink-0 relative overflow-hidden rounded-[24px] md:rounded-[26px]
                 w-[88vw] xs:w-[78vw] sm:w-[62vw] md:w-[46vw] lg:w-[36vw] xl:w-[30vw]
                 aspect-[16/10] ring-1 ring-black/10 bg-transparent
                 shadow-[0_14px_50px_rgba(0,0,0,.12)] focus:outline-none focus:ring-4 focus:ring-black/10"
        >
          <div class="card-lift absolute inset-0 will-change-transform">
            <img src={s.img} alt={s.title} class="absolute inset-0 h-full w-full object-cover" loading="lazy" decoding="async" />
            <div class="pointer-events-none absolute inset-x-0 bottom-0 h-1/2
                        bg-[linear-gradient(180deg,rgba(0,0,0,0)_0%,rgba(0,0,0,.22)_45%,rgba(0,0,0,.55)_100%)]"></div>
          </div>
          <div class="absolute inset-0 grid place-items-end p-6">
            <h3 class="text-white text-[clamp(20px,3.0vw,34px)] font-extrabold tracking-tight drop-shadow">
              {s.title}
            </h3>
          </div>
        </a>
      ))}
    </div>
  </div>
</section>

<!-- Interactions -->
<script is:inline>
(() => {
  const track = document.getElementById('svc-track');
  if (!track) return;

  /** Tunables */
  const BTN_PAGE_FACTOR = 0.85;   // used by arrow keys
  const EDGE_ZONE       = 120;    // px for hover glide
  const EDGE_SPEED_MAX  = 18;     // px / frame for edge glide
  const DRAG_FRICTION   = 0.93;   // momentum decay
  const WHEEL_MULT      = 1.0;    // vertical wheel -> horizontal

  /* 1) Wheel â†’ horizontal */
  track.addEventListener('wheel', (e) => {
    // convert vertical scroll to horizontal if it dominates
    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
      track.scrollLeft += e.deltaY * WHEEL_MULT;
      e.preventDefault();
    }
  }, { passive: false });

  /* 2) Click/drag with momentum */
  let isDown = false, startX = 0, startLeft = 0, lastX = 0, vx = 0, raf = 0;
  const stopRAF = () => raf && cancelAnimationFrame(raf);
  const momentum = () => {
    if (Math.abs(vx) < 0.25) return;
    track.scrollLeft -= vx;
    vx *= DRAG_FRICTION;
    raf = requestAnimationFrame(momentum);
  };
  track.addEventListener('pointerdown', (e) => {
    isDown = true;
    startX = lastX = e.clientX;
    startLeft = track.scrollLeft;
    vx = 0;
    stopRAF();
    track.setPointerCapture(e.pointerId);
  });
  track.addEventListener('pointermove', (e) => {
    if (!isDown) return;
    const dx = e.clientX - startX;
    track.scrollLeft = startLeft - dx;
    vx = e.clientX - lastX;
    lastX = e.clientX;
  });
  const endDrag = (e) => {
    if (!isDown) return;
    isDown = false;
    try { e.pointerId && track.releasePointerCapture(e.pointerId); } catch {}
    momentum();
  };
  track.addEventListener('pointerup', endDrag);
  track.addEventListener('pointerleave', () => { isDown = false; });

  /* 3) Keyboard arrows (focusable track) */
  const page = (dir) => track.scrollBy({ left: dir * track.clientWidth * BTN_PAGE_FACTOR, behavior: 'smooth' });
  track.setAttribute('tabindex', '0');
  track.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowRight') { page(+1); e.preventDefault(); }
    if (e.key === 'ArrowLeft')  { page(-1); e.preventDefault(); }
  });

  /* 4) Edge hover glide (use the dedicated zones) */
  const leftZone  = document.getElementById('svc-hover-left');
  const rightZone = document.getElementById('svc-hover-right');

  if (matchMedia('(pointer:fine)').matches && leftZone && rightZone) {
    let hoverRAF = 0;
    const startGlide = (dir) => (e) => {
      const zone = dir < 0 ? leftZone : rightZone;
      const rect = zone.getBoundingClientRect();
      const step = () => {
        // distance into the zone (0..EDGE_ZONE)
        const mx = Math.max(0, Math.min(EDGE_ZONE,
          dir < 0 ? (window.event.clientX - rect.left) : (rect.right - window.event.clientX)
        ));
        const t = 1 - (mx / EDGE_ZONE);            // 0 (edge) .. 1 (deep in zone)
        const speed = dir * (EDGE_SPEED_MAX * t);
        track.scrollLeft += speed;
        hoverRAF = requestAnimationFrame(step);
      };
      cancelAnimationFrame(hoverRAF);
      hoverRAF = requestAnimationFrame(step);
    };
    const stopGlide = () => cancelAnimationFrame(hoverRAF);

    leftZone.addEventListener('mouseenter', startGlide(-1));
    rightZone.addEventListener('mouseenter', startGlide(+1));
    leftZone.addEventListener('mouseleave',  stopGlide);
    rightZone.addEventListener('mouseleave', stopGlide);
  }

  /* 5) Snap the nearest card to center after wheel settles */
  let snapTO;
  const cards = Array.from(track.querySelectorAll('.svc-card'));
  const snapCenter = () => {
    if (!cards.length) return;
    const mid = track.scrollLeft + track.clientWidth / 2;
    const nearest = cards.reduce((best, el) => {
      const cx = (el as HTMLElement).offsetLeft + (el as HTMLElement).offsetWidth / 2;
      const d = Math.abs(cx - mid);
      return d < best.d ? { el, d } : best;
    }, { el: cards[0], d: Infinity }).el as HTMLElement;
    nearest?.scrollIntoView({ inline: 'center', block: 'nearest', behavior: 'smooth' });
  };
  track.addEventListener('wheel', () => { clearTimeout(snapTO); snapTO = setTimeout(snapCenter, 140); }, { passive: true });

  /* 6) Subtle parallax hover on each card */
  cards.forEach((card) => {
    const lift = card.querySelector('.card-lift') as HTMLElement | null;
    if (!lift) return;
    card.addEventListener('mousemove', (e) => {
      const r = (card as HTMLElement).getBoundingClientRect();
      const rx = (e.clientX - r.left) / r.width - 0.5;
      const ry = (e.clientY - r.top)  / r.height - 0.5;
      lift.style.transform = `translate3d(${rx * 10}px, ${ry * 10}px, 0) scale(1.02)`;
    });
    card.addEventListener('mouseleave', () => {
      lift.style.transform = 'translate3d(0,0,0) scale(1)';
    });
  });
})();
</script>
