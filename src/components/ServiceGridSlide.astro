---
import { services } from "../config/siteConfig.js";

// services here don’t have id, so just keep href or default to "#"
const items = services.map((s) => ({
  ...s,
  href: s.href ?? "#",
}));
---

<section class="relative bg-neutral-50">
  <div id="svc-wrap" class="relative w-full overflow-hidden">
    <!-- Track -->
    <div
      id="svc-track"
      class="flex transition-transform duration-700 ease-out"
      style="will-change: transform;"
    >
      {items.map((s, i) => (
        <article
          class={`slide ${i === 0 ? "is-active" : ""} relative shrink-0 w-full`}
        >
          <!-- BUBBLE CONTAINER -->
          <div class="mx-auto max-w-[1600px] px-4 md:px-6">
            <div
              class="relative min-h-[500px] md:min-h-[600px] lg:min-h-[700px] rounded-3xl overflow-hidden shadow-2xl ring-1 ring-neutral-200/70"
            >
              <!-- Background image -->
              <img
                src={s.img}
                alt={s.title}
                class="absolute inset-0 h-full w-full object-cover rounded-3xl"
                loading="eager"
                decoding="async"
                fetchpriority="high" 
              />

              <!-- Gradient overlay -->
              <div
                class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-black/20 rounded-3xl"
              ></div>

              <!-- CONTENT: centered text + buttons -->
<div class="absolute inset-0 z-10 flex items-center justify-center">
  <div
    class="slide-content max-w-3xl mx-auto flex flex-col items-center justify-center text-center px-6 md:px-12 gap-4 md:gap-6"
  >
    <!-- text block -->
    <div>
      <h2
        class="stagger text-white text-4xl md:text-6xl lg:text-7xl font-black font-sans font-semibold tracking-tight leading-[0.9] mb-4 md:mb-6"
      >
        {s.title}
      </h2>

      {s.description && (
        <p
          class="stagger text-white/90 text-sm md:text-lg max-w-2xl mx-auto mb-6 leading-relaxed"
        >
          {s.description}
        </p>
      )}
    </div>

    <!-- buttons centered under text -->
    <div
      class="stagger mt-4 md:mt-6 flex gap-3 flex-wrap justify-center"
    >
      <a
        href={s.href}
        class="inline-flex items-center justify-center rounded-full bg-white px-6 md:px-8 py-3 md:py-4 text-sm md:text-base font-semibold text-neutral-900 hover:bg-neutral-100 transition-all hover:scale-105 shadow-lg"
      >
        Learn More
      </a>
      <a
        href="/contact"
        class="inline-flex items-center justify-center rounded-full border-2 border-white bg-transparent px-6 md:px-8 py-3 md:py-4 text-sm md:text-base font-semibold text-white hover:bg-white hover:text-neutral-900 transition-all"
      >
        Get Free Estimate
      </a>
    </div>
  </div>
</div>

              <!-- /content -->
            </div>
          </div>
          <!-- /bubble -->
        </article>
      ))}
    </div>

    <!-- Arrows -->
    <button
      id="svc-prev"
      class="hidden md:flex absolute left-4 md:left-8 top-1/2 -translate-y-1/2 h-12 w-12 md:h-14 md:w-14 rounded-full bg-white/95 backdrop-blur-sm flex items-center justify-center hover:bg-white transition-all z-30 shadow-xl"
      aria-label="Previous slide"
    >
      <svg
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2.5"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M15 18l-6-6 6-6" />
      </svg>
    </button>
    <button
      id="svc-next"
      class="hidden md:flex absolute right-4 md:right-8 top-1/2 -translate-y-1/2 h-12 w-12 md:h-14 md:w-14 rounded-full bg-white/95 backdrop-blur-sm flex items-center justify-center hover:bg-white transition-all z-30 shadow-xl"
      aria-label="Next slide"
    >
      <svg
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2.5"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M9 18l6-6-6-6" />
      </svg>
    </button>

    <!-- Dots -->
    <div
      id="svc-dots"
      class="absolute bottom-6 md:bottom-8 left-6 md:left-12 flex gap-2 md:gap-3 z-30"
    >
      {items.map((_, i) => (
        <button
          class="h-2 w-2 md:h-3 md:w-3 rounded-full bg-white/40 hover:bg-white/70 transition-all aria-[current=true]:bg-white aria-[current=true]:w-6 md:aria-[current=true]:w-8"
          aria-current={i === 0 ? "true" : "false"}
          aria-label={`Go to slide ${i + 1}`}
        ></button>
      ))}
    </div>

    <!-- Play/Pause -->
    <button
      id="svc-auto"
      class="absolute bottom-6 md:bottom-8 right-6 md:right-12 h-10 w-10 md:h-12 md:w-12 rounded-full bg-white/20 backdrop-blur-md flex items-center justify-center hover:bg-white/30 transition-all z-30"
      aria-label="Pause autoplay"
      data-state="playing"
      title="Pause/Play"
    >
      <svg
        class="icon-pause h-4 w-4 md:h-5 md:w-5 text-white"
        viewBox="0 0 24 24"
        fill="currentColor"
      >
        <path d="M6 5h4v14H6zM14 5h4v14h-4z" />
      </svg>
      <svg
        class="icon-play h-4 w-4 md:h-5 md:w-5 text-white hidden"
        viewBox="0 0 24 24"
        fill="currentColor"
      >
        <path d="M8 5v14l11-7z" />
      </svg>
    </button>
  </div>
</section>

<script is:inline>
(() => {
  const wrap = document.getElementById("svc-wrap");
  const track = document.getElementById("svc-track");
  const prev = document.getElementById("svc-prev");
  const next = document.getElementById("svc-next");
  const dots = Array.from(document.querySelectorAll("#svc-dots > button"));
  const autoBtn = document.getElementById("svc-auto");

  if (!wrap || !track) return;

  const AUTO_MS = 5000;
  const DURATION_MS = 720;
  const EASING = "cubic-bezier(.22,.61,.36,1)";
  const SWIPE_PX = 50;

  let autoTimer = null;
  let pausedByUser = false;
  let isAnimating = false;
  let index = 1; // internal index (with clones)
  let lastDir = 1;

  // real slide index we last animated (0..baseCount-1)
  let currentReal = -1;

  // ✅ hard suppression for wrap-around (clone <-> real snap)
  let wrapSuppress = false;

  // -------------------------------
  // CLONE SETUP
  // -------------------------------
  const baseSlides = Array.from(track.children);
  const baseCount = baseSlides.length;
  if (!baseCount) return;

  const firstClone = baseSlides[0].cloneNode(true);
  const lastClone = baseSlides[baseCount - 1].cloneNode(true);

  track.insertBefore(lastClone, baseSlides[0]);
  track.appendChild(firstClone);

  const slides = Array.from(track.children);
  slides.forEach((s) => (s.style.width = "100%"));

  // -------------------------------
  // TRANSITION CONTROL
  // -------------------------------
  const setTransition = (on) => {
    track.style.transition = on ? `transform ${DURATION_MS}ms ${EASING}` : "none";
  };

  const setTransform = () => {
    track.style.transform = `translate3d(-${index * 100}%,0,0)`;
  };

  const getRealIndex = (idx) => {
    if (idx === 0) return baseCount - 1;        // lastClone
    if (idx === baseCount + 1) return 0;        // firstClone
    return idx - 1;                             // real slides
  };

  const setDots = (realIdx) => {
    dots.forEach((dot, i) => dot.setAttribute("aria-current", String(i === realIdx)));
  };

  const setActiveClass = (idx, dir) => {
    slides.forEach((slide, i) => {
      const active = i === idx;
      slide.classList.toggle("is-active", active);
      if (active) slide.dataset.dir = dir === 1 ? "next" : "prev";
      else delete slide.dataset.dir;
    });
  };

  // -------------------------------
  // CONTENT ANIMATION (JS ONLY)
  // -------------------------------
  const killAnimations = (root) => {
    if (!root) return;
    if (root.getAnimations) root.getAnimations().forEach((a) => a.cancel());
  };

  const forceVisible = (el) => {
    if (!el) return;
    el.style.opacity = "1";
    el.style.transform = "translate3d(0,0,0)";
  };

  const animateContent = (realIdx, dir) => {
    // ✅ never animate during wrap snap
    if (wrapSuppress) return;

    // ✅ prevent double-run on same real slide
    if (realIdx === currentReal) return;
    currentReal = realIdx;

    const activeSlide = slides[index];
    if (!activeSlide) return;

    const content = activeSlide.querySelector(".slide-content");
    const items = Array.from(activeSlide.querySelectorAll(".slide-content .stagger"));

    if (!content) return;

    // Cancel any previous WAAPI and reset hard
    killAnimations(content);
    items.forEach(killAnimations);

    // Ensure everything starts clean (important!)
    [content, ...items].forEach((el) => {
      if (!el) return;
      el.style.opacity = "";
      el.style.transform = "";
    });

    const fromX = dir === 1 ? 44 : -44;

    content.animate(
      [
        { opacity: 0, transform: `translate3d(${fromX}px,0,0)` },
        { opacity: 1, transform: "translate3d(0,0,0)" },
      ],
      { duration: 520, easing: EASING, fill: "both" }
    );

    items.forEach((el, i) => {
      el.animate(
        [
          { opacity: 0, transform: `translate3d(${fromX * 0.6}px,0,0)` },
          { opacity: 1, transform: "translate3d(0,0,0)" },
        ],
        { duration: 520, delay: 110 + i * 95, easing: EASING, fill: "both" }
      );
    });
  };

  // -------------------------------
  // WRAP SNAP (CLONE -> REAL)
  // -------------------------------
  const snapIfNeeded = () => {
    // ✅ IMPORTANT: during snap we suppress content animation for a couple frames
    const suppressFor2Frames = () => {
      wrapSuppress = true;
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          wrapSuppress = false;
        });
      });
    };

    if (index === baseCount + 1) {
      // landed on firstClone -> snap to real first (1)
      suppressFor2Frames();

      // update "current real" so it won't animate again
      currentReal = 0;

      setTransition(false);
      index = 1;
      setTransform();
      track.getBoundingClientRect();
      setTransition(true);

      setActiveClass(index, 1);
      setDots(0);

      isAnimating = false;
      return true;
    }

    if (index === 0) {
      // landed on lastClone -> snap to real last (baseCount)
      suppressFor2Frames();

      currentReal = baseCount - 1;

      setTransition(false);
      index = baseCount;
      setTransform();
      track.getBoundingClientRect();
      setTransition(true);

      setActiveClass(index, -1);
      setDots(baseCount - 1);

      isAnimating = false;
      return true;
    }

    return false;
  };

  // -------------------------------
  // CORE MOVE
  // -------------------------------
  const go = (delta) => {
    if (isAnimating) return;
    isAnimating = true;

    lastDir = delta >= 0 ? 1 : -1;
    index += delta;

    setActiveClass(index, lastDir);
    setTransform();

    const real = getRealIndex(index);
    setDots(real);

    // ✅ If we're moving onto a clone, DO NOT animate content
    // (clone->real will snap, and we suppress anyway)
    const goingToClone = index === 0 || index === baseCount + 1;
    if (!goingToClone) {
      animateContent(real, lastDir);
    } else {
      // also lock currentReal so snap can’t trigger a second entrance
      currentReal = real;
    }

    window.clearTimeout(go._t);
    go._t = window.setTimeout(() => {
      if (!snapIfNeeded()) isAnimating = false;
    }, DURATION_MS + 140);
  };

  // -------------------------------
  // INIT
  // -------------------------------
  setTransition(false);
  setTransform();
  track.getBoundingClientRect();
  setTransition(true);

  setActiveClass(index, 1);
  setDots(0);

  // ensure first slide is visible (no flicker)
  const initSlide = slides[index];
  forceVisible(initSlide?.querySelector(".slide-content"));
  initSlide?.querySelectorAll(".slide-content .stagger").forEach(forceVisible);

  // animate first slide once
  animateContent(0, 1);

  track.addEventListener("transitionend", (e) => {
    if (e.propertyName && e.propertyName !== "transform") return;
    window.clearTimeout(go._t);
    if (!snapIfNeeded()) isAnimating = false;
  });

  // -------------------------------
  // AUTOPLAY
  // -------------------------------
  const startAuto = () => {
    if (pausedByUser) return;
    stopAuto();
    autoTimer = window.setInterval(() => go(1), AUTO_MS);
  };

  const stopAuto = () => {
    if (autoTimer) window.clearInterval(autoTimer);
    autoTimer = null;
  };

  // -------------------------------
  // CONTROLS
  // -------------------------------
  prev?.addEventListener("click", () => { go(-1); startAuto(); });
  next?.addEventListener("click", () => { go(1); startAuto(); });

  dots.forEach((dot, targetReal) => {
    dot.addEventListener("click", () => {
      if (isAnimating) return;
      const current = getRealIndex(index);
      if (targetReal === current) return;

      // jump to internal index (real 0 -> idx 1)
      const targetInternal = targetReal + 1;
      go(targetInternal - index);
      startAuto();
    });
  });

  // -------------------------------
  // SWIPE
  // -------------------------------
  let x0 = 0;
  track.addEventListener("touchstart", (e) => {
    x0 = e.changedTouches[0].screenX;
  }, { passive: true });

  track.addEventListener("touchend", (e) => {
    const x1 = e.changedTouches[0].screenX;
    if (x1 < x0 - SWIPE_PX) go(1);
    if (x1 > x0 + SWIPE_PX) go(-1);
    startAuto();
  }, { passive: true });

  // -------------------------------
  // HOVER + PLAY/PAUSE
  // -------------------------------
  wrap.addEventListener("mouseenter", stopAuto);
  wrap.addEventListener("mouseleave", startAuto);

  autoBtn?.addEventListener("click", () => {
    pausedByUser = !pausedByUser;
    autoBtn.dataset.state = pausedByUser ? "paused" : "playing";
    autoBtn.querySelector(".icon-play")?.classList.toggle("hidden", !pausedByUser);
    autoBtn.querySelector(".icon-pause")?.classList.toggle("hidden", pausedByUser);
    pausedByUser ? stopAuto() : startAuto();
  });

  // -------------------------------
  // VISIBILITY / BF CACHE
  // -------------------------------
  const resync = () => {
    stopAuto();
    isAnimating = false;
    setTransition(false);
    setTransform();
    track.getBoundingClientRect();
    setTransition(true);

    setActiveClass(index, lastDir);
    setDots(getRealIndex(index));

    startAuto();
  };

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopAuto();
    else resync();
  });

  window.addEventListener("pageshow", (e) => {
    if (e.persisted) resync();
  });

  startAuto();
})();
</script>



<style>
  #svc-track { will-change: transform; transform: translate3d(0,0,0); backface-visibility: hidden; }
  #svc-track > article { width: 100%; }

  /* IMPORTANT: remove/override any old CSS animation rules */
  .slide.is-active .slide-content,
  .slide.is-active .slide-content .stagger,
  .slide[data-dir="next"] .slide-content,
  .slide[data-dir="next"] .slide-content .stagger,
  .slide[data-dir="prev"] .slide-content,
  .slide[data-dir="prev"] .slide-content .stagger {
    animation: none !important;
  }

  /* Reduce Safari text shimmer */
  .slide-content {
    transform: translate3d(0,0,0);
    -webkit-font-smoothing: antialiased;
    will-change: transform, opacity;
  }

  @media (prefers-reduced-motion: reduce) {
    #svc-track { transition: none !important; }
  }
</style>

