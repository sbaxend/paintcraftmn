---
import { services } from "../config/siteConfig.js";

// services here don’t have id, so just keep href or default to "#"
const items = services.map((s) => ({
  ...s,
  href: s.href ?? "#",
}));
---

<section class="relative bg-neutral-50">
  <div id="svc-wrap" class="relative w-full overflow-hidden">
    <!-- Track -->
    <div
      id="svc-track"
      class="flex transition-transform duration-700 ease-out"
      style="will-change: transform;"
    >
      {items.map((s, i) => (
        <article
          class={`slide ${i === 0 ? "is-active" : ""} relative shrink-0 w-full`}
        >
          <!-- BUBBLE CONTAINER -->
          <div class="mx-auto max-w-[1600px] px-4 md:px-6">
            <div
              class="relative min-h-[500px] md:min-h-[600px] lg:min-h-[700px] rounded-3xl overflow-hidden shadow-2xl ring-1 ring-neutral-200/70"
            >
              <!-- Background image -->
              <img
                src={s.img}
                alt={s.title}
                class="absolute inset-0 h-full w-full object-cover rounded-3xl"
                loading="eager"
                decoding="async"
                fetchpriority="high" 
              />

              <!-- Gradient overlay -->
              <div
                class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-black/20 rounded-3xl"
              ></div>

              <!-- CONTENT: centered text + buttons -->
<div class="absolute inset-0 z-10 flex items-center justify-center">
  <div
    class="slide-content max-w-3xl mx-auto flex flex-col items-center justify-center text-center px-6 md:px-12 gap-4 md:gap-6"
  >
    <!-- text block -->
    <div>
      <h2
        class="stagger text-white text-4xl md:text-6xl lg:text-7xl font-black font-sans font-semibold tracking-tight leading-[0.9] mb-4 md:mb-6"
      >
        {s.title}
      </h2>

      {s.description && (
        <p
          class="stagger text-white/90 text-sm md:text-lg max-w-2xl mx-auto mb-6 leading-relaxed"
        >
          {s.description}
        </p>
      )}
    </div>

    <!-- buttons centered under text -->
    <div
      class="stagger mt-4 md:mt-6 flex gap-3 flex-wrap justify-center"
    >
      <a
        href={s.href}
        class="inline-flex items-center justify-center rounded-full bg-white px-6 md:px-8 py-3 md:py-4 text-sm md:text-base font-semibold text-neutral-900 hover:bg-neutral-100 transition-all hover:scale-105 shadow-lg"
      >
        Learn More
      </a>
      <a
        href="/contact"
        class="inline-flex items-center justify-center rounded-full border-2 border-white bg-transparent px-6 md:px-8 py-3 md:py-4 text-sm md:text-base font-semibold text-white hover:bg-white hover:text-neutral-900 transition-all"
      >
        Get Free Estimate
      </a>
    </div>
  </div>
</div>

              <!-- /content -->
            </div>
          </div>
          <!-- /bubble -->
        </article>
      ))}
    </div>

    <!-- Arrows -->
    <button
      id="svc-prev"
      class="hidden md:flex absolute left-4 md:left-8 top-1/2 -translate-y-1/2 h-12 w-12 md:h-14 md:w-14 rounded-full bg-white/95 backdrop-blur-sm flex items-center justify-center hover:bg-white transition-all z-30 shadow-xl"
      aria-label="Previous slide"
    >
      <svg
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2.5"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M15 18l-6-6 6-6" />
      </svg>
    </button>
    <button
      id="svc-next"
      class="hidden md:flex absolute right-4 md:right-8 top-1/2 -translate-y-1/2 h-12 w-12 md:h-14 md:w-14 rounded-full bg-white/95 backdrop-blur-sm flex items-center justify-center hover:bg-white transition-all z-30 shadow-xl"
      aria-label="Next slide"
    >
      <svg
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2.5"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M9 18l6-6-6-6" />
      </svg>
    </button>

    <!-- Dots -->
    <div
      id="svc-dots"
      class="absolute bottom-6 md:bottom-8 left-6 md:left-12 flex gap-2 md:gap-3 z-30"
    >
      {items.map((_, i) => (
        <button
          class="h-2 w-2 md:h-3 md:w-3 rounded-full bg-white/40 hover:bg-white/70 transition-all aria-[current=true]:bg-white aria-[current=true]:w-6 md:aria-[current=true]:w-8"
          aria-current={i === 0 ? "true" : "false"}
          aria-label={`Go to slide ${i + 1}`}
        ></button>
      ))}
    </div>

    <!-- Play/Pause -->
    <button
      id="svc-auto"
      class="absolute bottom-6 md:bottom-8 right-6 md:right-12 h-10 w-10 md:h-12 md:w-12 rounded-full bg-white/20 backdrop-blur-md flex items-center justify-center hover:bg-white/30 transition-all z-30"
      aria-label="Pause autoplay"
      data-state="playing"
      title="Pause/Play"
    >
      <svg
        class="icon-pause h-4 w-4 md:h-5 md:w-5 text-white"
        viewBox="0 0 24 24"
        fill="currentColor"
      >
        <path d="M6 5h4v14H6zM14 5h4v14h-4z" />
      </svg>
      <svg
        class="icon-play h-4 w-4 md:h-5 md:w-5 text-white hidden"
        viewBox="0 0 24 24"
        fill="currentColor"
      >
        <path d="M8 5v14l11-7z" />
      </svg>
    </button>
  </div>
</section>

<script is:inline>
(() => {
  const wrap = document.getElementById("svc-wrap");
  const track = document.getElementById("svc-track");
  const prev = document.getElementById("svc-prev");
  const next = document.getElementById("svc-next");
  const dots = Array.from(document.querySelectorAll("#svc-dots > button"));
  const autoBtn = document.getElementById("svc-auto");

  if (!wrap || !track) return;

  const AUTO_MS = 5000;
  const DURATION_MS = 700; // must match duration-700
  const EASING = "ease-out"; // must match ease-out

  let autoTimer = null;
  let pausedByUser = false;
  let isAnimating = false;
  let snapFallbackTimer = null;
  let lastDir = 1;

  // ✅ one-time flag for "we just snapped clone -> real"
  let skipAnimOnce = false;

  // -------------------------------
  // CLONE SLIDES (INFINITE LOOP)
  // -------------------------------
  const baseSlides = Array.from(track.children);
  const baseCount = baseSlides.length;
  if (!baseCount) return;

  const firstClone = baseSlides[0].cloneNode(true);
  const lastClone  = baseSlides[baseCount - 1].cloneNode(true);

  track.insertBefore(lastClone, baseSlides[0]);
  track.appendChild(firstClone);

  const slides = Array.from(track.children);
  let index = 1; // internal index (1..baseCount are real)

  // -------------------------------
  // HELPERS
  // -------------------------------
  const clearFallback = () => {
    if (snapFallbackTimer) clearTimeout(snapFallbackTimer);
    snapFallbackTimer = null;
  };

  const setTransform = () => {
    track.style.transform = `translateX(-${index * 100}%)`;
  };

  const restoreTransition = () => {
    track.style.transition = `transform ${DURATION_MS}ms ${EASING}`;
  };

  const getRealIndex = (idx) => {
    if (idx === 0) return baseCount - 1;
    if (idx === baseCount + 1) return 0;
    return idx - 1;
  };

  const setActive = (dir) => {
    const realIndex = getRealIndex(index);

    slides.forEach((slide, i) => {
      const active = i === index;

      slide.classList.toggle("is-active", active);

      if (active) {
        slide.dataset.dir = dir === 1 ? "next" : "prev";

        // ✅ If we just snapped, block animation on this active slide
        if (skipAnimOnce) slide.setAttribute("data-skip-anim", "true");
        else slide.removeAttribute("data-skip-anim");
      } else {
        delete slide.dataset.dir;
        slide.removeAttribute("data-skip-anim");
      }
    });

    // ✅ consume the one-time snap flag
    skipAnimOnce = false;

    dots.forEach((dot, i) =>
      dot.setAttribute("aria-current", String(i === realIndex))
    );
  };

  // -------------------------------
  // SNAP (HIDDEN) — removes "rewind"
  // -------------------------------
  const snapIfNeeded = () => {
    const lock = () => track.setAttribute("data-snapping", "true");
    const unlock = () => track.removeAttribute("data-snapping");

    const snapTo = (newIndex, dir) => {
      lock();

      // Kill transition and jump instantly
      track.style.transition = "none";
      index = newIndex;
      setTransform();

      // Force layout flush so jump commits without transition
      track.getBoundingClientRect();

      // ✅ IMPORTANT: mark "skip content anim" BEFORE setActive runs
      skipAnimOnce = true;
      setActive(dir);

      // Keep snapping locked across 2 frames so browsers never show the jump
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          restoreTransition();
          unlock();
          isAnimating = false;
        });
      });
    };

    // last real -> firstClone (index === baseCount + 1)
    if (index === baseCount + 1) {
      snapTo(1, 1); // snap to real first, direction "next"
      return true;
    }

    // first real -> lastClone (index === 0)
    if (index === 0) {
      snapTo(baseCount, -1); // snap to real last, direction "prev"
      return true;
    }

    return false;
  };

  // -------------------------------
  // INIT
  // -------------------------------
  track.style.transition = "none";
  setTransform();
  setActive(1);
  requestAnimationFrame(() => {
    restoreTransition();
  });

  // -------------------------------
  // STEP LOGIC
  // -------------------------------
  const step = (delta) => {
    if (isAnimating) return;
    isAnimating = true;

    clearFallback();
    lastDir = delta >= 0 ? 1 : -1;

    index += delta;
    setTransform();
    setActive(lastDir);

    // Fallback if transitionend never fires
    snapFallbackTimer = setTimeout(() => {
      if (!snapIfNeeded()) isAnimating = false;
    }, DURATION_MS + 120);
  };

  track.addEventListener("transitionend", (e) => {
    if (e.propertyName && e.propertyName !== "transform") return;
    clearFallback();
    if (!snapIfNeeded()) isAnimating = false;
  });

  // -------------------------------
  // AUTOPLAY
  // -------------------------------
  const startAuto = () => {
    if (pausedByUser) return;
    if (autoTimer) clearInterval(autoTimer);
    autoTimer = setInterval(() => step(1), AUTO_MS);
  };

  const stopAuto = () => {
    if (autoTimer) clearInterval(autoTimer);
    autoTimer = null;
  };

  // -------------------------------
  // CONTROLS
  // -------------------------------
  prev?.addEventListener("click", () => { step(-1); startAuto(); });
  next?.addEventListener("click", () => { step(1); startAuto(); });

  dots.forEach((dot, realTarget) => {
    dot.addEventListener("click", () => {
      const currentReal = getRealIndex(index);
      if (realTarget === currentReal || isAnimating) return;

      clearFallback();
      isAnimating = true;

      lastDir = realTarget > currentReal ? 1 : -1;
      index = realTarget + 1;

      setTransform();
      setActive(lastDir);

      snapFallbackTimer = setTimeout(() => {
        isAnimating = false;
      }, DURATION_MS + 120);

      startAuto();
    });
  });

  // -------------------------------
  // SWIPE (MOBILE)
  // -------------------------------
  let x0 = 0;

  track.addEventListener("touchstart", (e) => {
    x0 = e.changedTouches[0].screenX;
  }, { passive: true });

  track.addEventListener("touchend", (e) => {
    const x1 = e.changedTouches[0].screenX;
    if (x1 < x0 - 50) step(1);
    if (x1 > x0 + 50) step(-1);
    startAuto();
  }, { passive: true });

  // -------------------------------
  // VISIBILITY / BF CACHE FIX
  // -------------------------------
  const resync = () => {
    clearFallback();
    isAnimating = false;
    track.style.transition = "none";
    setTransform();
    track.getBoundingClientRect();
    requestAnimationFrame(() => {
      restoreTransition();
      setActive(lastDir);
    });
  };

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopAuto();
    else { resync(); startAuto(); }
  });

  window.addEventListener("pageshow", (e) => {
    if (e.persisted) { resync(); startAuto(); }
  });

  // -------------------------------
  // HOVER + PLAY/PAUSE
  // -------------------------------
  wrap.addEventListener("mouseenter", stopAuto);
  wrap.addEventListener("mouseleave", startAuto);

  autoBtn?.addEventListener("click", () => {
    pausedByUser = !pausedByUser;
    autoBtn.dataset.state = pausedByUser ? "paused" : "playing";
    autoBtn.querySelector(".icon-play")?.classList.toggle("hidden", !pausedByUser);
    autoBtn.querySelector(".icon-pause")?.classList.toggle("hidden", pausedByUser);
    pausedByUser ? stopAuto() : startAuto();
  });

  startAuto();
})();
</script>


<style>
  /* Ensure slides fill width */
  #svc-track > article { width: 100%; }

  /* Initial state based on direction */
  .slide[data-dir="next"] .slide-content,
  .slide[data-dir="next"] .slide-content .stagger {
    opacity: 0;
    transform: translateX(100px);
  }

  .slide[data-dir="prev"] .slide-content,
  .slide[data-dir="prev"] .slide-content .stagger {
    opacity: 0;
    transform: translateX(-100px);
  }

  /* ✅ During snapping (clone -> real), disable content animation so snap is invisible */
  #svc-track[data-snapping] .slide-content,
  #svc-track[data-snapping] .slide-content .stagger {
    animation: none !important;
    transform: none !important;
    opacity: 1 !important;
  }

  /* ✅ If we skip anim, FORCE the content to be visible (otherwise it stays at opacity:0) */
  .slide[data-skip-anim] .slide-content,
  .slide[data-skip-anim] .slide-content .stagger {
    opacity: 1 !important;
    transform: none !important;
    animation: none !important;
  }


  /* active: slide in from the direction we’re moving */
  .slide.is-active[data-dir="next"]:not([data-skip-anim]) .slide-content {
    animation: slideInFromRight 0.7s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  .slide.is-active[data-dir="prev"]:not([data-skip-anim]) .slide-content {
    animation: slideInFromLeft 0.7s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  .slide.is-active[data-dir="next"]:not([data-skip-anim]) .stagger {
    animation: staggerFromRight 0.7s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  .slide.is-active[data-dir="prev"]:not([data-skip-anim]) .stagger {
    animation: staggerFromLeft 0.7s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  /* Simple delays that won’t break if a subtitle is missing */
  .slide.is-active:not([data-skip-anim]) .stagger:nth-of-type(1) { animation-delay: 0.12s; }
  .slide.is-active:not([data-skip-anim]) .stagger:nth-of-type(2) { animation-delay: 0.22s; }
  .slide.is-active:not([data-skip-anim]) .stagger:nth-of-type(3) { animation-delay: 0.32s; }
  .slide.is-active:not([data-skip-anim]) .stagger:nth-of-type(4) { animation-delay: 0.42s; }

  @keyframes slideInFromRight {
    from { opacity: 0; transform: translateX(100px); }
    to   { opacity: 1; transform: translateX(0); }
  }

  @keyframes slideInFromLeft {
    from { opacity: 0; transform: translateX(-100px); }
    to   { opacity: 1; transform: translateX(0); }
  }

  @keyframes staggerFromRight {
    from { opacity: 0; transform: translateX(22px); }
    to   { opacity: 1; transform: translateX(0); }
  }

  @keyframes staggerFromLeft {
    from { opacity: 0; transform: translateX(-22px); }
    to   { opacity: 1; transform: translateX(0); }
  }

  @media (prefers-reduced-motion: reduce) {
    .slide .slide-content,
    .slide .slide-content .stagger {
      animation: none !important;
      opacity: 1 !important;
      transform: none !important;
    }
  }
</style>
