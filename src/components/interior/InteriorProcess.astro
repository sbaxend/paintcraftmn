---
/** ---------- Types & props (Astro front-matter supports TS) ---------- */
type Stage = {
  id: string;
  title: string;
  desc: string;
  img: string; // path under /public (e.g. "/prep.png")
};

export interface Props {
  heading?: string;
  stages?: Stage[];
}

const {
  heading = "We handle everything",
  stages = [
    {
      id: "prep",
      title: "Prep & Protect",
      desc: "We carefully protect furniture & floors, then prep all surfaces for perfect paint adhesion.",
      img: "/prep.png",
    },
    {
      id: "paint",
      title: "Paint & Perfect",
      desc: "Expert application with premium paints for smooth, even coverage and flawless results.",
      img: "/perfect.png",
    },
    {
      id: "clean",
      title: "Clean & Inspect",
      desc: "Thorough clean-up and a detailed walkthrough to make sure you love every detail.",
      img: "/inspect.png",
    },
  ],
} = Astro.props as Props;

const sectionId = "interior-process";
const stageIds = stages.map((s) => s.id);
---

<section id={sectionId} class="relative bg-white">
  <!-- Tight heading so the effect starts sooner -->
  <div class="mx-auto max-w-7xl px-6 pt-6 pb-3">
    <h2 class="text-center font-serif text-3xl md:text-5xl font-semibold text-neutral-900">
      {heading}
    </h2>
  </div>

  <!-- SCROLL REGION (enter + pin + exit) -->
  <div data-wrapper class="relative h-[340vh]">
    <!-- STICKY VIEWPORT -->
    <div class="sticky top-0 h-screen overflow-hidden">
      <!-- MEDIA BUBBLE (contained → near-fullscreen) -->
      <div class="absolute inset-0 flex items-center justify-center">
        <div
          id="ip-bubble"
          class="relative aspect-[16/9] w-[88vw] md:w-[80vw] max-w-[1400px] rounded-[28px] overflow-hidden
                 shadow-[0_20px_80px_rgba(0,0,0,.25)] ring-1 ring-black/10"
          style="transform:translateZ(0) scale(.70); opacity:0;"
        >
          {stages.map((s, idx) => (
            <img
              src={s.img}
              alt={s.title}
              class={`slide absolute inset-0 h-full w-full object-cover opacity-0 transition-opacity duration-500 ease-out ${idx === 0 ? "opacity-100" : ""}`}
              data-idx={idx}
              loading={idx === 0 ? "eager" : "lazy"}
              decoding="async"
            />
          ))}
          <!-- vignette for text legibility -->
          <div class="pointer-events-none absolute inset-0 bg-[linear-gradient(180deg,rgba(0,0,0,.15)_0%,rgba(0,0,0,.35)_60%,rgba(0,0,0,.45)_100%)]"></div>
        </div>
      </div>

      <!-- TEXT OVERLAY -->
      <div class="absolute inset-0 flex items-end md:items-center justify-center pb-10 md:pb-0">
        <div class="mx-auto max-w-4xl px-6 text-center">
          {stages.map((s, idx) => (
            <div
              class={`copy absolute left-1/2 -translate-x-1/2 w-full max-w-3xl opacity-0 transition-opacity duration-400 ${idx === 0 ? "opacity-100" : ""}`}
              data-idx={idx}
            >
              <h3 class="text-white drop-shadow text-3xl md:text-5xl font-extrabold">
                {s.title}
              </h3>
              <p class="mt-4 text-white/90 text-base md:text-lg">{s.desc}</p>
            </div>
          ))}
        </div>
      </div>
    </div>

    <!-- MARKERS (1 full screen per stage) -->
    <div class="relative">
      {stageIds.map((id) => (
        <div id={`marker-${id}`} class="h-screen"></div>
      ))}
    </div>
  </div>

  <!-- Data payload for the client script -->
  <script type="application/json" id="ip-data" set:html={JSON.stringify({ sectionId, stageIds })} />
</section>

<!-- ========= Client Script (runs in place; no hoisting) ========= -->
<script is:inline>
  const run = () => {
    const dataEl = document.getElementById('ip-data');
    if (!dataEl) return;

    // ---- Tunables (adjust to taste) ----
    const ENTER_EARLY       = 0.28; // start fade/scale BEFORE the wrapper hits viewport (0..1 of vh)
    const START_SCALE       = 0.70; // scale at very first contact
    const MID_SCALE         = 0.96; // scale by end of enter
    const EXIT_SCALE        = 0.70; // scale at end of exit
    const WRAP_VH           = 500;  // wrapper height (syncs with h-[340vh])
    const FULL_ON_AT        = 0.16; // during pin: when to expand to near-fullscreen
    const FULL_OFF_AT       = 0.94; // when to release near-fullscreen
    const FULL_GUTTER_VW    = 0;    // keep a small side gutter in fullscreen
    const FULL_TRANSITION_MS= 420;  // sizing transition speed
    // -----------------------------------

    let data = {};
    try { data = JSON.parse(dataEl.textContent || '{}'); } catch {}

    const root    = document.getElementById(data.sectionId);
    if (!root) return;

    const bubble  = root.querySelector('#ip-bubble');
    const slides  = Array.from(root.querySelectorAll('.slide'));
    const copies  = Array.from(root.querySelectorAll('.copy'));
    const wrapper = root.querySelector('[data-wrapper]');
    const markers = (data.stageIds || []).map(id => document.getElementById(`marker-${id}`)).filter(Boolean);

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const vh    = () => window.innerHeight;

    const measure = () => {
      if (wrapper) wrapper.style.height = `${WRAP_VH}vh`;

      const wTop     = (wrapper?.getBoundingClientRect().top || 0) + window.scrollY;
      const firstTop = (markers[0]?.getBoundingClientRect().top || 0) + window.scrollY;

      const enterStart = wTop - vh() * ENTER_EARLY;
      const enterEnd   = firstTop;
      const pinStart   = firstTop;
      const lastTop    = (markers[markers.length - 1]?.getBoundingClientRect().top || 0) + window.scrollY;
      const pinEnd     = lastTop + vh(); // one full screen for last marker
      const exitEnd    = pinEnd + vh() * 0.7;

      const markerTops = markers.map(m => (m?.getBoundingClientRect().top || 0) + window.scrollY);
      return { enterStart, enterEnd, pinStart, pinEnd, exitEnd, markerTops };
    };

    let geom = measure();
    let resizeTO;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTO);
      resizeTO = setTimeout(() => { geom = measure(); onScroll(); }, 120);
    });

    const setActive = (idx) => {
      slides.forEach((el, i) => (el.style.opacity = i === idx ? '1' : '0'));
      copies.forEach((el, i) => (el.style.opacity = i === idx ? '1' : '0'));
    };

    const applyFullscreen = (on) => {
      if (!bubble) return;
      if (on && bubble.dataset.full !== '1') {
        bubble.dataset.full     = '1';
        bubble.style.transition = `width ${FULL_TRANSITION_MS}ms ease, height ${FULL_TRANSITION_MS}ms ease, max-width ${FULL_TRANSITION_MS}ms ease, border-radius ${FULL_TRANSITION_MS}ms ease, box-shadow ${FULL_TRANSITION_MS}ms ease`;
        const g = Math.max(0, FULL_GUTTER_VW);
        bubble.style.width        = `calc(100vw - ${g}vw * 2)`;
        bubble.style.height       = '100vh';
        bubble.style.maxWidth     = 'none';
        bubble.style.borderRadius = '0px';
        bubble.style.boxShadow    = 'none';
        bubble.style.transform    = 'translateZ(0) scale(1)';
        bubble.style.opacity      = '1';
      } else if (!on && bubble.dataset.full === '1') {
        bubble.dataset.full     = '';
        bubble.style.width        = '';
        bubble.style.height       = '';
        bubble.style.maxWidth     = '';
        bubble.style.borderRadius = '';
        bubble.style.boxShadow    = '';
      }
    };

    const onScroll = () => {
      const y = window.scrollY;
      const { enterStart, enterEnd, pinStart, pinEnd, exitEnd, markerTops } = geom;

      // ENTER (fade + scale up early)
      if (y <= enterEnd) {
        const p = clamp((y - enterStart) / (enterEnd - enterStart), 0, 1);
        if (bubble) {
          const s = START_SCALE + (MID_SCALE - START_SCALE) * p;
          bubble.style.opacity   = String(p);
          bubble.style.transform = `translateZ(0) scale(${s})`;
        }
        applyFullscreen(false);
        setActive(0);
        return;
      }

      // PIN (step through slides; expand to near-fullscreen)
      if (y > enterEnd && y <= pinEnd) {
        let idx = 0;
        for (let i = 0; i < markerTops.length; i++) {
          if (y >= markerTops[i] - 8) idx = i;
        }
        setActive(idx);

        const pinProg = clamp((y - pinStart) / (pinEnd - pinStart), 0, 1);
        if (bubble) {
          const s = MID_SCALE + (1.0 - MID_SCALE) * clamp(pinProg * 1.05, 0, 1);
          bubble.style.opacity   = '1';
          bubble.style.transform = `translateZ(0) scale(${s})`;
        }
        applyFullscreen(pinProg >= FULL_ON_AT && pinProg <= FULL_OFF_AT);
        return;
      }

      // EXIT (shrink + fade)
      const p = clamp((y - pinEnd) / (exitEnd - pinEnd), 0, 1);
      if (bubble) {
        const s = 1.0 + (EXIT_SCALE - 1.0) * p;
        bubble.style.transform = `translateZ(0) scale(${s})`;
        bubble.style.opacity   = String(1 - p);
      }
      applyFullscreen(false);
    };

    // Ensure first slide shows immediately
    setActive(0);
    window.addEventListener('scroll', onScroll, { passive: true });
    onScroll();
  };

  // run now (and also safe if DOM’s not ready yet)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
</script>
